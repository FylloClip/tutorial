[
  {
    "objectID": "PCBs.html",
    "href": "PCBs.html",
    "title": "PCBs",
    "section": "",
    "text": "Here you can download the production files for the PCB needed to create the control unit (Arduino board) as well as the PCBs used as foliar sensors.\nThe files are provided in two different formats, gerber and EasyEDA. The gerber files can be used directly to place an order with a PCB manufacturer, whereas the EasyEDA files can be uploaded to the EasyEDA PCB design software where they can be edited and modified before placing an order.\n\nArduino board\n\n\n\nArduino board PCB\n\n\nGerber format\nEasyEDA format\n\n\nFylloClip sensors\nWhen ordering the foliar sensors, please make sure to select a PCB thickness of 1 mm. If the thickness is more than 1 mm, the sensor will be too stiff an difficult to be placed on a leaf. I have always chosen the white colour, but probably it does not make much of a difference if you choose another colour.\nlarger size:\n\n\n\nfoliar sensor, larger size\n\n\nGerber format\nEasyEDA format\nsmaller size:\n\n\n\nfoliar sensor, smaller size\n\n\nGerber format\nEasyEDA format",
    "crumbs": [
      "Home",
      "***HARDWARE***",
      "PCBs"
    ]
  },
  {
    "objectID": "instructions for soldering.html",
    "href": "instructions for soldering.html",
    "title": "instructions for soldering",
    "section": "",
    "text": "Download link for a Video showing how to solder the LoRa module onto the main PCB:\nsolder RFM95"
  },
  {
    "objectID": "device_registration.html",
    "href": "device_registration.html",
    "title": "device registration on TTN",
    "section": "",
    "text": "Each device needs to be registered on the ‘The Things Network’ platform (TTN) for becoming fully operational.\nFirst, create a free account on The Things Network: https://www.thethingsnetwork.org/get-started\n\nOnce you’ve signed up and created your account, you’ll need to create an ‘application’. This can be thought of as a group of end devices managed similarly in terms of their structure and data transmission.\n\n\nAfter creating the application, you’ll need to specify some settings for subsequent data handling. One crucial step is to insert a payload formatter, i.e. a code which will transform the incoming data into a format suitable for your intended data flow.\nThe data flow and management proposed in this tutorial is only one of many possible options. Here, we will decode the incoming data packet and transform it to a JSON object containing 5 variables named Z, A, B, C, D and E. Z will hold the ID number of the device, A the light measurement of sensor 1, B the light measurement of sensor 2, C the capacitance value of sensor 1, D the capacitance value of sensor 2 and E the battery voltage.\nTo enter the payload formatter for the application, select Payload formatters –&gt; Uplink and then choose Custom Javascript formatter as the formatter type. In the field Formatter code paste the follwing code:\nfunction Decoder(bytes, port) {\n\n  return {\n    \n  //Sensor ID\n  Z: (bytes[0]),\n  \n  //light 1\n  A: ((bytes[2] &lt;&lt; 8) | bytes[1]),\n  \n  //light 2\n  B: ((bytes[4] &lt;&lt; 8) | bytes[3]),\n  \n  //capacitance 1\n  C: (bytes[5]),\n  \n  //capacitance 2\n  D: (bytes[6]),\n  \n  //Battery voltage\n  //round to 2 decimal places\n  E:+((((bytes[8] &lt;&lt; 8) | bytes[7]))*3.3/1023).toFixed(2)\n  }\n}\n\nHaving inserted the payload formatter at the application level, it will be automatically applied to all end devices which will be created within this application. Alternatively, it is also possible to specifiy a payload formatter individually for a single end device.\nAnother important setting at the application level is to specifiy, what the TTN network server should do with the decoded data packets. Data cannot be permanently stored on TTN, therefore they need to be forwarded to some other storage place on the cloud. Again, there are many possible options for this to be achieved, The settings necessary for the solution proposed here are explained more in detail in the paragraph storing the data in the cloud.\nNext, you can start with the registration of end devices (each FylloClip module would be a single new end device)\n\nFollow the settings in the subsequent screenshots (if you’re located outside of Europe select the frequency plan applicable to your region).\n\nnext, select ABP and generate the DevEUI and the various keys:\n\nAfter registration we have to edit the newly created device to add a few further and to copy the keys we need to insert into the Arduino sketch\n\nScroll down and expand the Network layer settings\n\nScroll down and open the advanced MAC settings\n\nClick 9 times on the ‘add frequency’ button to add 9 empty fields\n\nIn those fields insert the following frequencies, this example reports the frequencies used for Europe (868 MHz frequency band), which are 868100000, 868300000, 868500000, 867100000, 867300000, 867500000, 867700000, 867900000, 868800000. Add the end save the changes.\n\nNow we retrieve the keys to be inserted into the Arduino sketch. Return to ‘Device overview’\n\nMake NwkSKey and AppSKey visible\n\nMove the cursor to the right side of the key fields to activate the formatting options, the change the format as follows. At the end copy each key using the copy function and insert them in the respective positions of the Arduino sketch.\n\n\n\nYou can also specify a unique ID number for your device (line 12 of the code), which may be helpful for later data handling. At this point the sketch id ready for the upload onto your device.",
    "crumbs": [
      "Home",
      "***SOFTWARE***",
      "device registration on TTN"
    ]
  },
  {
    "objectID": "cloud.html",
    "href": "cloud.html",
    "title": "storing the data in the cloud",
    "section": "",
    "text": "In the paragraph device registration on TTN we have seen how an end device (FylloClip module) is registered on the TTN network. With this we enabled the data flow from the device in the field to the TTN network server, provided of course that there is TTN coverage at the site, which means that there needs to be a LoRa-gateway connected to TTN somewhere in the area. On TTNmapper you can find out if there is already TTN coverage in a specific location. If not, you will need to install your own LoRa gateway and register it on TTN.\nAs already mentioned in device registration on TTN, the TTN network server cannot be used for storing data. But we can provide instructions for the data to be forwarded to another destination in the cloud where the data can b stored in a database. There are various approaches to achieve this goal, what is explained here is just one of them and consists in forwarding the data, which have already been formatted to a JSON object (according to the payload formatter inserted when creating the application on TTN), to another website which provides a hosting service. There are many free web hosting services out there, for this tutorial we use altervista.org.\nAs the first step, you need to create your own (free) account. Choose the option Hosting with file manager. Although there appears a monthly cost, there will be the option for a free account at the next step.\n\nType in the desired name of your website and see if it is available. Follow the procedure for registration and after receiving a confirmation e-mail you will be the proud owner of the new website.\n\nOnce the website is created, two further steps are needed, namely to set up the database and to add a script which will accept the data-packets coming in from the TTN network server and insert the data into the database.\nLet’s first set up the database:\n\n\nOnce created the database access the PhpMyAdmin area. If you want, you can also activate the https protocol.\n\nWithin PhpMyAdmin we can now manage the database. Inside this database we need to create tables which will finally store the data. If you have several FylloClip modules, you will need a separate table for each one. You may remember that inside the Arduino code, which was uploaded to the microcontroller board, we specified the variable ID and assigned a value to this variable. Suppose this is your first module to which you assigned ID=1. The data of this module will end up in the table with the name tbl_1. But we have to create this table first.\nThe easiest way to achieve this is to access the SQL register and insert there the following code:\nCREATE TABLE `tbl_1` ( \n  `ID` int PRIMARY KEY,  \n  `Server_Time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP, \n  `A` int NOT NULL COMMENT 'L1', \n  `B` int NOT NULL COMMENT 'L2', \n  `C` int NOT NULL COMMENT 'C1', \n  `D` int NOT NULL COMMENT 'C2', \n  `E` float NOT NULL COMMENT 'Battery' \n) ENGINE=MyISAM DEFAULT CHARSET=latin1;\n\n\nThereafter you will see on the left that a new table named tbl_1 has been added to the database. You can use the same script to add further tables, like tbl_2, tbl_3 and so on.\n\nBut how can our data reach a table in the database? First, we need to tell the TTN server to forward the data to our altervista website, then we need to have a small piece of code on altervista which will accept the data coming in from TTN and insert the values into the respective tables.\nphp script on altervista\nLog into your altervista website and go to File management.\n\nnext, create a new php-file and give it a name:\n\ninside the window, which will open, paste the following code and hit save:\n&lt;?php \n    //Receive from TTN\n $postdata = file ('php://input');\n\n//decode the JSON object and assign values to variables\n$data = json_decode($postdata[0]);\n\n$Z = $data-&gt;uplink_message-&gt;decoded_payload-&gt;Z;\n$A = $data-&gt;uplink_message-&gt;decoded_payload-&gt;A;\n$B = $data-&gt;uplink_message-&gt;decoded_payload-&gt;B;\n$C = $data-&gt;uplink_message-&gt;decoded_payload-&gt;C;\n$D = $data-&gt;uplink_message-&gt;decoded_payload-&gt;D;\n$E = $data-&gt;uplink_message-&gt;decoded_payload-&gt;E;\n\n//connect to database and insert values\n$link = mysqli_connect(\"localhost\", \"foliarsensors\", \"\", \"my_foliarsensors\");\n\n//error handling\nif (!$link) {die('Impossibile connettersi: ' . mysqli_error());}\n\n$table_id = \"tbl_\".$Z;\n\n$sql = \"INSERT INTO $table_id\n(ID, Server_Time, A, B, C, D, E)\nVALUES (NULL, CURRENT_TIMESTAMP, $A, $B, $C, $D, $E);\";\n\n$retval = mysqli_query ($link, $sql);\n\n//error handling\nif(! $retval ){\ndie('impossible to execute the query: ' . mysqli_error());\n}\n\n//close connection to db\nmysqli_close($link);\n\n?&gt;\n\nForwarding the data from TTN to altervista\nThis is achieved by specifying a path inside the TTN console which will channel the data to the above script. Go to the application you have already created and select integrations –&gt; webhooks –&gt; add webhook\n\nnext, choose custom webhook:\n\ngive the webhook a name and insert the address of your altervista website and then insert the name of the php-script which will later handle the the flow of the data into your database. At the bottom of the page, hit add webhook.\n\nNow we should have everything in place for our dataflow to start…",
    "crumbs": [
      "Home",
      "***SOFTWARE***",
      "storing the data in the cloud"
    ]
  },
  {
    "objectID": "assembly_instructions.html",
    "href": "assembly_instructions.html",
    "title": "assembly instructions",
    "section": "",
    "text": "Microcontroller board\nThe starting point is the empty PCB.\n \nAdding the LoRa module is the most tricky part, therefore solder it as the first component onto the empty PCB, so that you will not be hindered by the presence of other components​.\nHere a video showing how to solder the LoRa module onto the main PCB: solder RFM95\nNow continue with the remaining components, it doesn’t matter in which order, but it will be easier to add the 10K resistor before adding the socket for the Atmega328.\n  \nNow most of the components have been added… before inserting the Atmega328 chip into the socket, you need to burn the bootloader for the Pro Mini Arduino (8Mhz, 3.3V) onto it.​\nIf you want to monitor the battery voltage, solder a bridge between the two tiny solder plates marked with ‘batt_mon’ (yellow circle in the above pic), this will create a link between battery VCC and an analog pin of the micrcontroller.\nInstead of the male pin header (on the left) you can add a female header, depending on the type of FTDI adapter you will use for programming.​\nThe antenna (top right) is a piece of wire of 8.6 cm length.​\nFylloClip sensor\n \nHere you see the top and bottom side of a FylloClip sensor. The only component which needs to be added is the SFH203P photodiode acting as light sensor​.\n \nThe photodiode has a polarity, so you need to pay attention to its correct placement. In order to place it correctly, make sure that the flat edge of the photodiode coincides with the outline of the photodiode printed on the sensor PCB.\nOn the bottom side of the sensor PCB you see four small solder pads, marked with ‘c’, ‘c’, ‘-’ and ‘+’. Onto these pads you have to solder the end of the cables, which will connect the sensor to the microcontroller board. Connect the cables so that they point towards the centre of the sensor plate (see images below), this will allow you later to attach the sensors to the leaf with the cables not protruding from the side of the leaf running straight under the leaf towards the petiole where they can be fixed to the leaf (see paragraph ‘attaching the sensor to the leaf’).\nTry to use very thin and lightweight cables of about 1mm outer diameter. At the end put some nail polish on the soldered contacts, around the base of the photodiode and on both sides of the vias (tiny holes where copper traces pass from one side of the PCB to the other).\n \nThe red arrows indicate the places where to apply nail polish as a protective coating to prevent moisture from getting on the circuit.\nOnce you have soldered the cables to the foliar sensor and applied the polish, you can further fix the cables by adding a small cable tie passing through the two small holes on the sensor.\nImportant note: the new foliar sensors should be gently washed with soap or dish soap because it seems that some residue of the production process hinders the condensation of water vapour on their surface. Experience shows that after washing the sensitivity of the sensors greatly improves.\n\n\n\nFully completed foliar sensor\n\n\nWiring of the sensors to the micrcontroller board:\n\nWiring of the battery:\n\nThe final result:",
    "crumbs": [
      "Home",
      "***ASSEMBLY***",
      "assembly instructions"
    ]
  },
  {
    "objectID": "burning_bootloader.html",
    "href": "burning_bootloader.html",
    "title": "burning the bootloader",
    "section": "",
    "text": "The bootloader is a small program that must be present on a microcontroller in order to be used in the Arduino environment. The bootloader enables the chip to receive code via the USB connection (using the Arduino IDE).\nIf you buy an ATmega chip from a supplier of electronic components, most likely it will come without the bootloader. Here you find the instructions on how to upload (‘burn’) a bootloader with the settings required for our particular purpose on a ATmega328P chip.\nThere are various possible ways to burn a bootloader, the easiest approach is to use another Arduino as the programming device for the new chip. For more details, see https://docs.arduino.cc/built-in-examples/arduino-isp/ArduinoISP/\n\nThe above picture explains the setup with two Arduino Uno boards, one is used as programmer, the other as target. The target is the board which holds the virgin ATmega chip which needs to receive the bootloader. The programmer board will be connected to the PC via the USB cable, the target board will only be connected to the programmer board by 6 jumper wires as shown in the picture above.\nAs the first step, the sketch ‘ArduinoISP’ needs to be uploaded onto the ‘programmer’ Arduino board.\n\nFor this step, the selected type of board in the Arduino IDE must be ‘Arduino UNO’\n\nAfter uploading this sketch onto the programmer board, change the selection to ‘Arduino Pro or Pro Mini’ :\n\nIn addition, select the option ‘ATmega328 (3.3V 8MHz)’ under Tools&gt;Processor\n\nNext, select ‘Arduino as ISP’ as the type of programmer:\n\nWith these settings, give the command to burn the bootloader onto the target chip:\n\nIf nothing goes wrong, the bootloader should now be transferred onto the target chip. With such a setup, however, this process frequently fails since jumper wires often don’t provide a perfectly stable connection.\nIn order to avoid such problems, you can assemble a special programming board:\n\nThe design for this PCB can be downloaded here. In addition to the PCB you need two 28-pin sockets, two 10K resistors, two 16 MHz crystals, four 22pF capacitors and a 6-pin header pin. The process of burning a bootloader will be exactly the same as described above. Of course you will need a ATmega328 chip with Arduino Uno bootloader already present to start with.",
    "crumbs": [
      "Home",
      "***HARDWARE***",
      "burning the bootloader"
    ]
  },
  {
    "objectID": "code for Arduino.html",
    "href": "code for Arduino.html",
    "title": "uploading the code",
    "section": "",
    "text": "In order to become fully operational, a software program needs to be uploaded to the microcontroller board. Here you find this code (or ‘sketch’, as it is called in Arduino language) for downloading, as well as some additional instructions. The sketch includes all the functions and routines for the system to operate, i.e. to carry out measurements at defined time intervals and to send the data over the LoRa network to the cloud. Here the download link for the Arduino code: Arduino code\nThe sketch needs to be uploaded to your microcontroller board. This can be easily done with the Arduino IDE (integrated development environment), which can be freely downloaded from the internet and installed on your PC. If you need more details about this step, visit: https://support.arduino.cc/hc/en-us/articles/360019833020-Download-and-install-Arduino-IDE\nThere are a few things to explain about this sketch. It is designed to run the FylloClip module in ABP (activation by personalisation) mode, which is one of two possibles modes of establishing a connection of a device to a LoRa network. This is not the officially recommended mode (which would be over the air activation, or OTAA), but it has the advantage of using a much more lightweight library (TinyLoRa) and that under some circumstances it uses less power.\nThe ABP mode of activating the device requires 3 unique identification keys to be inserted into the sketch before uploading it to the device. These are the network session key (NwkSkey), the application session key (AppSkey) and device address (DevAddr). You will obtain these codes when registering a new end device on the TTS console, after creating your own personal account there. It is important to copy and paste the keys in the hexadecimal format displaying an 0x in front of each number\nIn addition, for your own use, you can assign an ID-number from 0 - 99 to each device.\n\n\n\npart of the Arduino sketch with the ID- number in line 11 and the identification keys in lines 15, 18 and 21.\n\n\nThis code requires the installation of the TinyLora library. You can install the library with the library manager of the Arduino IDE, which you find unter tools –&gt; manage libraries. The screenshot below provides further details.\nAfter installing the library, you have to find the folder of your PC, where the libraries are installed (normally something like …Arduino/libraries/TinyLoRa). In this folder edit the file TinyLoRa.h with a text editor and modify, if needed, the settings for the region configuration. In the picture below so see the correct settings for Europe. You can change the settings by commenting or uncommenting the respective lines of interest.\n\n\n\nTinyLora library\n\n\n\n\n\nselect the correct frequency band for your region by commenting/uncommenting the respective lines of code\n\n\nYou need also to install the Low-Power library from Rocket Scream, which allows the board to go into power-saving sleep mode between measurements.\nYou can download the library here: https://github.com/rocketscream/Low-Power\n\n\n\nLow-Power library\n\n\nFor uploading the code you need a FTDI adapter. On the adapter select 3.3V power supply by positioning the jumper. This is important because the LoRa module on the board requires a supply voltage of 3.3 V and could be damaged if we set the voltage to 5 V.\n\n\n\nFTDI adapter\n\n\nIf you have installed male pin headers on your microcontroller board, you need to solder a female pin connector onto your FTDI adapter:\n\n\n\nFTDI adapter with modified connector pins\n\n\n\n\n\nFTDI adapter connected to the microprocessor board for programming\n\n\nBefore uploading the sketch make sure you have the correct board settings in the Arduino IDE: the selected board should be ‘Arduino Pro or Pro Mini’ with ‘ATmega328P(3.3V 8 Mhz)’ as processor. Make also sure you have selected the COM port to which the FTDI adapter is connected.\n\n\n\nBoard settings in the Arduino IDE\n\n\nOnce uploaded the sketch, you should be able to communicate with the board via the serial terminal of the IDE. the required settings for the serial monitor are ‘no line ending’ and ‘9600 baud’:\n\nAs soon as you start the serial terminal, the menu shown in the above screenshot appears. It will remain active only for a few seconds, after which the board goes into sleep mode. You can reactivate the menu by closing the serial terminal and opening it again. Then type immediately one of the letters of the options in the menu and hit ‘enter’.\ns - provides you an overview of actual settings and data\nr - resets the frame counter to zero.\nz - triggers the board to take sensor measurements and to send a data packet\na - allows you to set the desired time interval between successive measurements, with the following options: 01-05-10-15-20-30-60 minutes. Please enter always double digits, e.g. 05 instead of 5. A time interval of 10 minutes has proved to be appropriate.\nf - allows you to set the spreading factor for LoRa radio transmission, ranging from 07 to 12. Increasing values mean a longer distance of data transmission, but also at a higher energy and time consumption. So better start with 07 and increase only if necessary.",
    "crumbs": [
      "Home",
      "***SOFTWARE***",
      "uploading the code"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "FylloClip tutorial",
    "section": "",
    "text": "This tutorial aims to enable anyone to create and deploy their own fully functional FylloClip module capable of remote data transmission via the LoRaWAN network. It will guide you from ordering PCBs (printed circuit boards), purchasing electronic components, assembling and programming the system, to setting up remote data transmission. Ultimately, this will enable you to remotely monitor the water status of plants, transmitting data from the field to the cloud. Consequently, you can check on your PC or mobile phone, anytime and anywhere, if they are experiencing water stress.\nThis entire system can be replicated at a very low cost and requires only basic electronics skills (like soldering) and some familiarity with microcontrollers, particularly Arduino.\nWhat can a FylloClip sensor do and what can’t it do?\nFylloClip sensors can provide reliable indications of whether a plant is optimally supplied with water or if drought stress due to water deficiency is setting in.\nFylloClip sensors do not measure transpiration rates, although the signal of the capacitive part is strongly influenced by the transpiration of the leaf. Therefore, FylloClip sensors are not porometers. They provide a qualitative information regarding the water status of a plant, and not a quantitative reference value.\nWhat is the ideal application area for FylloClip sensors?\nFylloClip sensors are particularly suitable for plants with deep or widely extensive root systems, where soil moisture sensors, due to their very localized measurements, have only limited significance. FylloClip sensors provide information about the general water status of plants as affected by the availability of water in the entire soil volume explored by their roots.\nThe scientific background and working principle of these foliar sensors, named ‘FylloClip’ due to their paperclip-like attachment, are explained in detail in the following publication:\nA leaf-mounted capacitance sensor for continuous monitoring of foliar transpiration and solar irradiance as an indicator of plant water status\n\n\n\nFylloClip sensor on apple leaf\n\n\n\n\n\nFylloClip on grapevine\n\n\n\n\n\n\n\n\nA fully assembled FylloClip module\n\n\n\nExample of sensor output on a well watered plant: the capacitance values closely follow the pattern of solar radiation.\n\n\n\n\n\nExample of sensor output showing the onset of water stress through an early drop in capacitance that increasingly deviates from the pattern of solar radiation."
  },
  {
    "objectID": "list of components.html",
    "href": "list of components.html",
    "title": "electronic components",
    "section": "",
    "text": "The circuit board is relatively simple and consists of a microcontroller chip, a LoRa radio module and a few additional components.\nThe main parts of the system:\n \nATmega328P-PU with 8 Mhz crystal and 2 capacitors (22pF). The ATmega328P chip needs to have the bootloader for the Arduino board version ‘Pro or Pro Mini’ with the processor selection ‘ATmega328P (3.3V, 8 MHz)’ burned onto it. More details about burning the bootloader here.\n \nRFM95w LoRa module\n \nVoltage regulator (boost DC-DC converter)\n\na few resistors, connectors, capacitors,…\n\nBattery holder for 2 AA batteries\nHere a detailed list of all the required electronic components with links to a possible supplyer:\n\n\n\ncomponent​\nlink​\n\n\nphotodiode​\nhttps://www.reichelt.com​\n\n\nmicrocontroller atmega328 with bootloader for Arduino Pro Mini 3.3V​\nhttps://www.reichelt.com (you need to burn the bootloader onto the chip by yourself)​\n\n\nbattery holder​\nhttps://www.reichelt.com​\n\n\nCrystal 8 Mhz​\nhttps://www.reichelt.com​\n\n\nLoRa mosule RFM95w​\nhttps://www.soselectronic.com​\n\n\nSocket for microcontroller​\nhttps://www.reichelt.com​\n\n\nMale header pins ​\nhttps://www.reichelt.com​\n\n\nFemale header pins​\nhttps://www.reichelt.com (only in case you want to use female headers for the serial port)​\n\n\nResistor 4.7K​\nhttps://www.reichelt.com​\n\n\nResistor 10K​\nhttps://www.reichelt.com​\n\n\nCapacitor 100nF​\nhttps://www.reichelt.com​\n\n\nCapacitor 22pF​\nhttps://www.reichelt.com​\n\n\nconnector cable\nhttps://www.reichelt.com\n\n\nStep-up voltage regulator​\nhttps://www.aliexpress.com​",
    "crumbs": [
      "Home",
      "***HARDWARE***",
      "electronic components"
    ]
  }
]